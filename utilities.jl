using MAT
using Plots
using StatsBase
using SparseArrays
using LinearAlgebra
include("displaygraph.jl")


# A random sample of the graph of size "percent" % of the graph size
#
#   Parameters:
#       A = adjacency matrix for a graph G        (SparseMatrixCSC{Float64,Int64})
#       percent = percent of the sample size to the size of G     (Float64)
#   Return type: Vector{Int64}
function random_seed_percent(A::SparseMatrixCSC{Float64,Int64}, percent::Float64)
    len = size(A)[1]
    num = Int(floor(0.01*percent*len))
    return sample(1:len, num, replace = false)
end

# Volume of a set 
#
#   Parameters: 
#       A = adjacency matrix for a graph G        (SparseMatrixCSC{Float64,Int64})
#       S = node indices for a set in G      (Vector{Int64})
#   Return type: Float64 
function vol_S(A::SparseMatrixCSC{Float64,Int64}, S::Vector{Int64})
    return sum(A[:,S].nzval)
end

# Local conductance of the parameter set S
#
#   Parameters: 
#       A = adjacency matrix for a graph G        (SparseMatrixCSC{Float64,Int64})
#       S = node indices for a set in G     (Vector{Int64})
#       R = node indices for a seed set in G        (Vector{Int64})
#       epsilon = locality parameter        (Float64)
#   Return type: Float64
function local_cond(A::SparseMatrixCSC{Float64,Int64}, R::Vector{Int64}, 
                    S::Vector{Int64}, epsilon::Float64)
    volR = vol_S(A, R)
    vol_R = vol_S(complement_set(A,R))
    volA = sum(A.nzval)

    cut_S, vol_S, edges_S, cond_S = set_stats(A,S,volA)
    volRS = vol_S(findall(in(R),S))
    vol_RS = vol_S(findall(!in(R),S))

    local_c = cut_S/(volRS-epsilon*vol_RS)

    if local_c >= (volR/vol_R)
        return local_c
    end
        return 0
end

# The complement of set R in the graph
#
#   Parameters: 
#       A = adjacency matrix for a graph G        (SparseMatrixCSC{Float64,Int64})
#       S = node indices for a set in G     (Vector{Int64})
#   Return type: Vector{Int64}
function complement_set(A::SparseMatrixCSC{Float64,Int64}, S::Vector{Int64})
    inS = ones(size(A,1))
    inS[S] .= 0
    return findall(x->x!=0,inS)
end

# Given a node indice v, the seed set R is generated by growing a one hop neighborhood 
# FlowSeed is run with this R and given epsilon values, return the node indices of sets 
# corresponding to different epsilons, cut value of the sets, and set sizes respectively
#
#   Parameters: 
#       A = adjacency matrix for a graph G        (SparseMatrixCSC{Float64,Int64})
#       v = node index to grow a seed set      (Int64)
#       R = node indices of a seed set from one hop neighborhood of v in G        (Vector{Int64})
#       epsilons = an array of locality parameters (preferably in increasing order)        (Vector{Float64})
#       includeallR = indicator used to force R to be in the set returned or not        (Bool)
#   Return type: Vector{Vector{Int64}}, Vector{Int64}, Vector{Int64}
function FlowSeed_on_a_node(A::SparseMatrixCSC{Float64,Int64}, v::Int64, 
    epsilons::Vector{Float64}, includeallR::Bool)

    R = neighborhood(A,[v],1)
    numR = length(R)
    pR = zeros(numR,1)
    RinS = zeros(numR,1)
     
    if includeallR
        pR = ones(numR, 1)
        RinS = ones(numR, 1)
    end
    
    set_v = Vector{Vector{Int64}}()
    cut_v = Int64[]
    set_sizes = Int64[]

    for (index, value) in enumerate(epsilons)
       set, cond = FlowSeed(A, R, value, pR, RinS)
       cut, vol, edges, cond = set_stats(A,vec(set),sum(A.nzval))
       push!(set_v, vec(set))
       push!(cut_v, cut)
       push!(set_sizes, length(set))
    end

    return set_v, cut_v, set_sizes
end

# Iteratively call FlowSeed_on_a_node to get the information on a set of nodes
#
#   Parameters: 
#       A = adjacency matrix for a graph G        (SparseMatrixCSC{Float64,Int64})
#       nodes = node indices of the set to run FlowSeed on      (Vector{Int64})
#       start_num = index of the node to start from in "nodes"        (Int64)
#       end_num = index of the node to end in "nodes"        (Int64)
#       epsilons = an array of locality parameters (preferably in increasing order)        (Vector{Float64})
#       print = choose to print the result for each node or not        (Bool)
#       includeallR = indicator used to force R to be in the set returned or not        (Bool) 
#   Return type: Vector{Vector{Vector{Int64}}}, Vector{Vector{Int64}}, Vector{Vector{Int64}}
function FlowSeed_on_a_set(A::SparseMatrixCSC{Float64,Int64}, nodes::Vector{Int64}, 
    start_num::Int64, end_num::Int64, epsilons::Vector{Float64}, print::Bool, includeallR::Bool)

    sets = Vector{Vector{Vector{Int64}}}()
    cuts = Vector{Vector{Int64}}()
    set_sizes_vs = Vector{Vector{Int64}}()

    counter = 1
    for v in nodes[start_num:end_num]
        if print
            println(string(string("--------------------------", counter),
            "----------------------------"))
        end
        set_v, cut_v, set_sizes_v = FlowSeed_on_a_node(A, v, epsilons, includeallR)

        push!(set_sizes_vs, set_sizes_v)
        push!(sets, set_v)
        push!(cuts, cut_v)
        counter += 1
    end
    return sets, cuts, set_sizes_vs
end

# For an array values corresponding to different sets returned from different epsilons, detect the trend
# For the return value: 1 = same, 2 = increase, 3 = decrease, 4 = fluctuate
#
#   Parameters:
#       arr = array of sets-related values including cuts, set sizes        (Vector{Int64})
#   Return type: Int64
function each_node_trend(arr::Vector{Int64})
    inc = sort(arr)
    dec = sort(arr, rev = true)
    
    if inc == dec
        return 1
    else
        if arr == inc
            return 2 
        elseif arr == dec
            return 3
        else 
            return 4
        end     
    end
end

# Iteratively call each_node_trend to get information on a set of nodes, return the node
# indices of nodes with values remaining same, increasing, decreasing and fluctuating respectively
#
#   Parameters:
#       arr = 2d array of sets-related values including cuts, set sizes for a set of nodes (Vector{Vector{Int64}})
#   Return type: Vector{Int64}, Vector{Int64}, Vector{Int64}, Vector{Int64}
function classify_sets_by_trend(arr::Vector{Vector{Int64}})
    same = Any[] 
    inc = Any[] 
    dec = Any[] 
    fluc = Any[]
    trend = 0

    for i in 1:length(arr)
        trend = each_node_trend(arr[i])
        if trend == 1
            push!(same,i)
        elseif trend == 2
            push!(inc, i)
        elseif trend == 3
            push!(dec, i)
        else
            push!(fluc, i)
        end
    end
    return same, inc, dec, fluc
end


# Save set related information to a mat of dictionary
#
#   Parameters:
#       sets = indices of the "epsilon sets" for a set of nodes        (Vector{Vector{Vector{Int64}}})
#       cut = cut value of each set in "sets"       (Vector{Vector{Int64}})
#       set_sizes = set sizes of each set in "sets"       (Vector{Vector{Int64}})
#       dataset = name of the dataset       (String)
#       from = starting index of the nodes in the dataset       (Int64)
#       to = end index of the ndoes in the dataset      (Int64)
#   Return type: N/A, but saves a mat of above information to a dictionary
function save_to_mat(sets::Vector{Vector{Vector{Int64}}}, 
    cuts::Vector{Vector{Int64}}, set_sizes::Vector{Vector{Int64}}, 
    dataset::String, from::Int64, to::Int64)
    matwrite(string(string(dataset, string("_", string(from, string("-",to))),".mat")),
    Dict("set" => sets, "cut" => cuts, "set_sizes" => set_sizes);)
end

# Plot several sets returned by FlowSeed corresponding to a single node with different epsilons
#
#   Parameters:
#       A = adjacency matrix for a graph G        (SparseMatrixCSC{Float64,Int64})
#       node = index of the node to plot        (Int64)
#       index = index of the node within the information set        (Int64)
#       sets = indices of sets corresponding to different epsilons for a set of nodes        (Vector{Vector{Vector{Int64}}})
#       trend = indicator to get the sets with desired trends on the "values":
#               1. fluctuating  2. increasing  3. decreasing                (Int64)
#       epsilons = an array of locality parameters (preferably in increasing order)
#       values = set related information of each set in "sets"       (Vector{Vector{Int64}})
#       style = plotting style, preferably "kk" for most graphs        (String)
#       title = title of the plot       (String)
#       collapse = indicator to collapse the neighborhood nodes if there are too many       (Bool)
#   Return type: N/A, but plots several "epsilon sets" of the given node
function plot_sets(A::SparseMatrixCSC{Float64,Int64}, node::Int64, index::Int64, 
    sets::Vector{Vector{Vector{Int64}}}, trend::Int64, epsilons::Vector{Float64},
    values::Vector{Vector{Int64}}, style::String, title::String, collapse::Bool)
    
    indices = get_indices(values[index], trend)
    values = values[index]
    if indices === nothing 
        indices = Vector{Int64}()
        uniques = unique(values)
        for u in uniques
            push!(indices, last(findall(x->x == u, values)))
        end
    end

    S = sets[index]
    R = neighborhood(A, [node], 1)
    essential_nodes = Vector{Int64}()
    for i in 1:length(indices)
        essential_nodes = union(essential_nodes, S[indices[i]])
    end
    neigh = neighborhood(A, essential_nodes, 1)

    to_plot = union(neigh, essential_nodes)
    sample_to_plot = neigh
    
    if length(neigh) > 20 && collapse
        sample_indices = sample(1:length(neigh), 20, replace=false)
        sample_to_plot = neigh[sample_indices]
        to_plot = union(sample_to_plot, essential_nodes)
    end

    toplot_indices = Vector{Vector{Int64}}()

    for i in 1:length(indices)
        push!(toplot_indices, findall(x->x in S[indices[i]], to_plot))
    end

    R_indices = findall(x->x in R, to_plot)
    original = findall(x->x == node, to_plot)
    Asubgraph = A[to_plot, to_plot]
    
    xy = igraph_layout(Asubgraph, style)
    f = displaygraph(Asubgraph, xy)     

    sizes = [15, 12, 9, 6, 3]
    colors = [:yellow, :darkorange1, :orangered3, :firebrick, :darkred]

    for i in 1:length(indices)
        scatter!(f, xy[toplot_indices[i], 1], xy[toplot_indices[i], 2], markershape = :circle, 
        markeralpha = 0.5, markerstrokewidth = 2, markerstrokecolor = :black, 
        markerstrokestyle = :solid, markercolor = colors[i], markersize = sizes[i],
        label = "Epsilon = "*string(epsilons[indices[i]]))
    end
    
    scatter!(f, xy[R_indices,1], xy[R_indices,2], markershape = :circle, markersize = 3, 
    markercolor = :white, markerstrokewidth = 1.5, markerstrokecolor = :black, markerstrokestyle = :solid, 
    label = "Seed set R")

    scatter!(f, xy[original, 1], xy[original, 2], markershape = :star4, markersize = 3,  markerstrokewidth = 3,
    markercolor = :black, label = "Original Node")    

    plot!(size=(600,360), title=title, legend=:topright, legendfontsize=9, fontfamily = "Times")
end


# Information of sets with respect to different epsilons stored in matrix, and a string that directly
# outputs tables in latex
#   Parameters:
#       A = adjacency matrix for a graph G        (SparseMatrixCSC{Float64,Int64})
#       node = index of the node to plot        (Int64)
#       index = index of the node within the information set        (Int64)
#       epsilons = locality parameters that sets information corresponding to       (Vector{Float64})
#       all_epsilons = array of all epsilon values used in the experiment       (Vector{Float64})
#       sets = indices of sets corresponding to different epsilons for a set of nodes        (Vector{Vector{Vector{Int64}}})
#       cut = cut value of each set in "sets"       (Vector{Vector{Int64}})
#       toprint = choose to print the table or not      (Bool)
#   Return type: Vector{Vector{Float64}}, string
function epsilon_table(A::SparseMatrixCSC{Float64,Int64}, node::Int64, index::Int64, epsilons::Vector{Float64}, 
    all_epsilons::Vector{Float64}, sets::Vector{Vector{Vector{Int64}}}, cuts::Vector{Vector{Int64}}, toprint::Bool)
    epsilon_indices = findall(x->x in epsilons, all_epsilons)
    R = neighborhood(A,[node],1)
    n = length(epsilons)
    table = Vector{Vector{Float64}}()
    latex = "\\begin{center}"*"\n \\textbf{Node "*string(node)*
    "}\n \\begin{tabular}{||c |c c c c c c c c||} \n
    \\hline & \$ \\phi_{\\epsilon_1} \$ & \$ \\phi_{\\epsilon_2} \$ & 
    \$ \\phi_{\\epsilon_3} \$ &  \$ cut(S)\$ & \$ vol( \\bar{R} 
    \\cap S) \$ & \$ vol(R \\cap S) \$ & \$ vol(S)\$ & \$|S|\$ \\\\ [0.5ex]
    \n \\hline \\hline \n"
    output = "Node "*string(node)*"\n" 
    for i in 1:n
        latex = latex*(string("\$ \\epsilon_"*string(i)*"\$ = ", all_epsilons[epsilon_indices[i]]))
        info = Vector{Float64}(undef, n+5)
        S = sets[index][epsilon_indices[i]]
        for j in 1:n
            info[j] = local_cond(A, R, S, epsilons[j])
            if i == 1
                output = output*"Phi_{"*string(epsilons[j])*"}          "
            end
            latex = latex*string("&", round(info[j],digits=4))
        end
        if i == 1
            output = output*"cut(S) vol(R_bar_S) vol(R_S) \n"
        end
        info[n+1] = cuts[index][epsilon_indices[i]]
        info[n+3] = vol_R(A, intersect(R, S))
        info[n+4] = vol_R(A, S)
        info[n+2] = info[n+4]-info[n+3]
        info[n+5] = length(S)
        output = output*string(info)*"\n"
        latex = latex*"&"*string(Int(info[n+1]))*string("&",Int(info[n+2]))*string("&",Int(info[n+3]))
        latex = latex*string("&",Int(info[n+4]))*string("&",Int(info[n+5]))*"\\\\ \\hline \n"
        push!(table, info)
        output
    end
    latex=latex*"\\end{tabular} \n \\end{center}"

    if toprint
        print(output)
    end
    return table, latex
end

# Get the indices of the sets to plot based on the trend of certain value
#
#   Parameters:
#       values = set related values to decide which set to choose       (Vector{Int64})
#       trend = indicating which trend of the values we want to focus       (Int64)
#   Return type: Vector{Int64}
function get_indices(values::Vector{Int64}, trend::Int64)
    global uniques = unique(values)
    
    if length(uniques) == 3
        return [last(findall(x->x==uniques[1],values)),
        last(findall(x->x==uniques[2],values)),
        last(findall(x->x==uniques[3],values))]
    else
        if trend == 1       #fluctuating
            for i in 1:(length(uniques)-2)
                if (uniques[i] > uniques[i+1] && uniques[i+2] > uniques[i+1])||
                (uniques[i] < uniques[i+1] && uniques[i+2] < uniques[i+1])
                    return [last(findall(x->x==uniques[i],values)),
                    last(findall(x->x==uniques[i+1],values)),
                    last(findall(x->x==uniques[i+2],values))]
                end
            end
        elseif trend == 2       #increasing
            for i in 1:(length(uniques)-2)
                if (uniques[i] < uniques[i+1] && uniques[i+2] > uniques[i+1])||
                (uniques[i] < uniques[i+1] && uniques[i+2] > uniques[i+1])
                    return [last(findall(x->x==uniques[i],values)),
                    last(findall(x->x==uniques[i+1],values)),
                    last(findall(x->x==uniques[i+2],values))]
                end
            end
        elseif trend == 3       #decreasing
            for i in 1:(length(uniques)-2)
                if (uniques[i] > uniques[i+1] && uniques[i+2] < uniques[i+1])||
                (uniques[i] > uniques[i+1] && uniques[i+2] < uniques[i+1])
                    return [last(findall(x->x==uniques[i],values)),
                    last(findall(x->x==uniques[i+1],values)),
                    last(findall(x->x==uniques[i+2],values))]
                end
            end
        end
    end
end


# exhaustively search 
# is there no solution for smaller epsilon that contains LinearAlgebra
# some solution proves that no solution contains the other solution
# force R to be in the output set
# epsilon large enough, have to contain the seed set
# if don't contain all r, epsilon has to be smaller